#include "Input.hpp"

#include <Usagi/Module/Platform/WinCommon/Win32.hpp>
#include <Usagi/Module/Platform/WinCommon/WindowMessageTarget.hpp>

namespace usagi::win32
{
// https://docs.microsoft.com/en-us/windows/win32/api/winuser/ns-winuser-rawmouse#remarks
POINT convert_from_absolute_position(const Vector2f &pos)
{
    const float width = GetSystemMetrics(SM_CXVIRTUALSCREEN);
    const float height = GetSystemMetrics(SM_CYVIRTUALSCREEN);

    return {
        static_cast<LONG>(pos.x() / USHRT_MAX * width),
        static_cast<LONG>(pos.y() / USHRT_MAX * height)
    };
}

bool raw_input__handle_mouse(
    InputEventInserter &inserter,
    const tagRAWMOUSE &mouse,
    const MessageInfo &info)
{
    // todo: timestamp


    [[maybe_unused]]
    static Vector2f last_position;

    auto &archetype = inserter.archetype();
    auto &event = archetype.component<ComponentInputEvent>();

    Vector2f cursor_rel;
    const Vector2f cursor_abs = { info.cursor.x, info.cursor.y };

    // if the mouse position is absolute (e.g. sent by remote desktop software)
    // convert them to relative. note that typically only relative positions
    // are generated by windows.
    // see https://stackoverflow.com/questions/14113303/raw-input-device-rawmouse-usage
    if(mouse.usFlags & MOUSE_MOVE_ABSOLUTE)
    {
        assert(mouse.usFlags & MOUSE_VIRTUAL_DESKTOP);

        // when using remote desktop, the coordinates of mouse cursor ranges
        // from 0~65535 which covers the screen, a conversion using screen
        // size is therefore required.
        // see http://www.petergiuntoli.com/parsing-wm_input-over-remote-desktop
        // and https://stackoverflow.com/questions/31949476/raw-input-mouse-lastx-lasty-with-odd-values-while-logged-in-through-rdp
        // event.absolute = // screenPositionToActiveWindow(
        //     convert_from_absolute_position({ mouse.lLastX, mouse.lLastY });
        // );
        // todo the rel pos will be wrong after switching to another window
        // event.relative = abs - mLastPosition;
    }
    else
    {
        // abs = cursorPositionInActiveWindow();
        cursor_rel = { mouse.lLastX, mouse.lLastY };
    }
    last_position = cursor_abs;

    // when in GUI mode, only processes events inside the window rect
    // todo since we use raw input, we receive the mouse messages even if the
    // part of window is covered, in which case the user might perform
    // undesired actions.
    // if(!isImmersiveMode())
    // {
    //     const auto win_size = window->size();
    //     // todo process the input if any mouse button is pressed (dragging)
    //     if(abs.x() < 0 || abs.y() < 0 ||
    //         abs.x() >= win_size.x() || abs.y() >= win_size.y())
    //         return;
    // }

    // process mouse movement
    if(!cursor_rel.isZero())
    {
        event.axis = InputAxis::MOUSE_CURSOR;
        event.absolute = cursor_abs;
        event.relative = cursor_rel;
        inserter.insert();
    }

    auto btn_pressed = [&](int flag, InputAxis code) {
        if(mouse.usButtonFlags & flag)
        {
            event.axis = code;
            event.absolute = { 0, 1 };
            event.relative = { 0, 1 };
            inserter.insert();
        }
    };

    auto btn_released = [&](int flag, InputAxis code) {
        if(mouse.usButtonFlags & flag)
        {
            event.axis = code;
            event.absolute = { 0, 0 };
            event.relative = { 0, -1 };
            inserter.insert();
        }
    };
    // process mouse buttons & scrolling
    if(mouse.usButtonFlags)
    {
        // process mouse buttons
        // note that it is impossible to activate another window while holding
        // a mouse button pressed within the active window, so it is
        // unnecessary to clear button press states when deactivate the window.
        // however this is not the case for the keyboard.

        btn_pressed(RI_MOUSE_LEFT_BUTTON_DOWN, InputAxis::MOUSE_LEFT);
        btn_pressed(RI_MOUSE_MIDDLE_BUTTON_DOWN, InputAxis::MOUSE_MIDDLE);
        btn_pressed(RI_MOUSE_RIGHT_BUTTON_DOWN, InputAxis::MOUSE_RIGHT);
        btn_pressed(RI_MOUSE_BUTTON_4_DOWN, InputAxis::MOUSE_BUTTON_4);
        btn_pressed(RI_MOUSE_BUTTON_5_DOWN, InputAxis::MOUSE_BUTTON_5);

        btn_released(RI_MOUSE_LEFT_BUTTON_UP, InputAxis::MOUSE_LEFT);
        btn_released(RI_MOUSE_MIDDLE_BUTTON_UP, InputAxis::MOUSE_MIDDLE);
        btn_released(RI_MOUSE_RIGHT_BUTTON_UP, InputAxis::MOUSE_RIGHT);
        btn_released(RI_MOUSE_BUTTON_4_UP, InputAxis::MOUSE_BUTTON_4);
        btn_released(RI_MOUSE_BUTTON_5_UP, InputAxis::MOUSE_BUTTON_5);

        const auto wheel_delta = static_cast<short>(mouse.usButtonData) /
            static_cast<float>(WHEEL_DELTA);

        // process scrolling
        if(mouse.usButtonFlags & RI_MOUSE_WHEEL)
        {
            event.axis = InputAxis::MOUSE_WHEEL_Y;
            event.absolute = { 0, 0 };
            event.relative = { 0, wheel_delta };
            inserter.insert();
        }
        // horizontal scrolling, which seems to be undocumented.
        // found here: https://stackoverflow.com/questions/7942307/horizontal-mouse-wheel-messages-from-windows-raw-input
        if(mouse.usButtonFlags & RI_MOUSE_HWHEEL)
        {
            event.axis = InputAxis::MOUSE_WHEEL_X;
            event.absolute = { 0, 0 };
            event.relative = { wheel_delta, 0 };
            inserter.insert();
        }
    }

    return true;
}
}
